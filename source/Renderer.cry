import GFX;
import Math;

// determine model dimensions of the screen.
const LOGICAL_SCREEN_HEIGHT = .48;
const LOGICAL_SCREEN_WIDTH = LOGICAL_SCREEN_HEIGHT * SCREEN_WIDTH / SCREEN_HEIGHT;

enum ObjectType {
	TRIANGLE,
	CAR,
	TREE,
}

class Renderer {
	
	field playscene;
	
	// each object is a list:
	// - a type (enum above)
	// - sortable X
	// - sortable Y
	// - sortable Z
	// - sort priority tier (lower is closer, 0 is ground triangles, everything else that is standing upright is 1)
	
	// remaining objects for triangles
	// - an XYZ list for point A
	// - an XYZ list for point B
	// - an XYZ list for point C
	// - red
	// - green
	// - blue
	
	// remaining objects for billboard images
	// - logical width of the image.
	// - a pointer to an image getter
	// (the bottom center is the sortable XYZ
	
	field objects = [];
	
	field cameraX = 0;
	field cameraY = 0;
	field cameraZ = 0;
	
	// the components of the plane equation of the screen.
	// Nx * (x - x0) + Ny * (y - y0) + Nz * (z - z0) = Nc
	field Nx = 0;
	field Ny = 0;
	field Nz = 0;
	field Nc = 0;
	
	// Two points. The bottom two corners of the screen.
	field screenAx = 0;
	field screenAy = 0;
	field screenAz = 0;
	field screenBx = 0;
	field screenBy = 0;
	field screenBz = 0;
	
	constructor(playscene) {
		this.playscene = playscene;
		
		this.objects = [];
		for (y = 0; y < 10; ++y) {
			for (x = 0; x < 10; ++x) {
				color = (x + y) % 2 == 0 ? 255 : 0;
				a = [x + 0.0, y + 0.0, 0.0];
				b = [x + 1.0, y + 0.0, 0.0];
				c = [x + 1.0, y + 1.0, 0.0];
				d = [x + 0.0, y + 1.0, 0.0];
				
				cx = (a[0] + b[0] + c[0]) / 3;
				cy = (a[1] + b[1] + c[1]) / 3;
				cz = (a[2] + b[2] + c[2]) / 3;
				
				this.objects.add([ObjectType.TRIANGLE, [cx, cy, cz, 0], [a, b, c], [color, color, color]]);
				
				cx = (a[0] + d[0] + c[0]) / 3;
				cy = (a[1] + d[1] + c[1]) / 3;
				cz = (a[2] + d[2] + c[2]) / 3;
				
				this.objects.add([ObjectType.TRIANGLE, [cx, cy, cz, 0], [a, d, c], [color, color, color]]);
			}
		}
	}
	
	function drawBackground(playerTheta) {
		anglePercent = (playerTheta / Math.PI) % 1.0;
		GFX.Draw.fill(80, 180, 120);
		bg = ImageLibrary.get('backgrounds/level1.png');
		
		offset = Math.floor(anglePercent * bg.width);
		
		x = -offset;
		bg.draw(x, 0);
		x += bg.width;
		if (x < SCREEN_WIDTH) {
			bg.draw(x, 0);
		}
	}
	
	function getObjectDistance(object) {
		loc = object[1];
		dx = loc[0] - this.cameraX;
		dy = loc[1] - this.cameraY;
		dz = loc[2] - this.cameraZ;
		priorityTier = loc[3];
		return (dx ** 2 + dy ** 2 + dz ** 2) ** .5 - 10000000.0 * priorityTier;
	}
	
	function getSortedObjects() {
		this.objects.sort(this.getObjectDistance);
		return this.objects;
	}
	
	function render(counter) {
	
		player = this.playscene.player;
		playerX = player.x;
		playerY = player.y;
		playerZ = 0.0;
		toCamera = player.theta + Math.PI;
		
		this.drawBackground(player.theta);
		
		focusX = playerX;
		focusY = playerY;
		focusZ = .5; // look just above the player
		
		// determine the bottom center of the screen
		screenDistance = 2.0;
		screenX = Math.sin(toCamera) * screenDistance + focusX;
		screenY = Math.cos(toCamera) * screenDistance + focusY;
		screenZ = focusZ;
		
		// a unit vector that points from the focus point (player) to the screen
		mx = (screenX - focusX) / screenDistance;
		my = (screenY - focusY) / screenDistance;
		mz = (screenZ - focusZ) / screenDistance;
		
		// follow that same vector to determine where the camera is located.
		eyeScreenDistance = 1.0; // adjust this to make the view angle wider (smaller means wider)
		this.cameraX = screenX + mx * eyeScreenDistance;
		this.cameraY = screenY + my * eyeScreenDistance;
		this.cameraZ = screenZ + mz * eyeScreenDistance;
		
		theta = toCamera + HALF_PI;
		
		// calculate two corners of the screen on the bottom.
		this.screenAx = screenX + Math.sin(theta) * LOGICAL_SCREEN_WIDTH / 2;
		this.screenAy = screenY + Math.cos(theta) * LOGICAL_SCREEN_WIDTH / 2;
		this.screenAz = 0.5;
		
		this.screenBx = 2 * screenX - this.screenAx;
		this.screenBy = 2 * screenY - this.screenAy;
		this.screenBz = this.screenAz;
		
		// compute camera vectors (left and bottom of "screen")
		
		// left side of the screen is just a vertical vector along the height of the screen
		// since it doesn't tilt up or down
		Lx = 0.0;
		Ly = 0.0;
		Lz = LOGICAL_SCREEN_HEIGHT;
		
		// bottom side of the screen is level and goes between cA and cB
		Bx = this.screenBx - this.screenAx;
		By = this.screenBy - this.screenAy;
		Bz = this.screenBz - this.screenAz;
		
		// cross product to find normal vector which is part of the plane equation for the screen.
		this.Nx = Ly * Bz - By * Lz;
		this.Ny = Lz * Bx - Bz * Lx;
		this.Nz = Lx * By - Bx * Ly;
		this.Nc = this.Nx * this.screenAx + this.Ny * this.screenAy + this.Nz * this.screenAz;
		
		// The equation of the camera Plane is Nx * x + Ny * y + Nz * z = Nc
		
		for (object : this.getSortedObjects()) {
			switch (object[0]) {
				case ObjectType.TRIANGLE:
					this.renderTriangle(object[2], object[3]);
					break;
				default:
					break;
			}
		}
	}
	
	// reusable temporary point list.
	static field pts = [[0] * 3, [0] * 3, [0] * 3];
	
	function renderTriangle(ABC, rgb) {
		
		// how many points are on the screen?
		ptCount = 0;
		i = 3;
		while (--i >= 0) {
			triPoint = ABC[i];
			
			eqLeft = this.Nc - this.Nx * this.cameraX - this.Ny * this.cameraY - this.Nz * this.cameraZ;
			eqRight = 
				this.Nx * (triPoint[0] - this.cameraX) +
				this.Ny * (triPoint[1] - this.cameraY) +
				this.Nz * (triPoint[2] - this.cameraZ);
			
			if (eqRight == 0) {
				// does not intersect, i.e. line is parallel to the screen plane.
				t = null;
			} else {
				t = eqLeft / eqRight;
				if (t > 0) { // t < 0 indicates it's behind the camera
					ptCount++;
					pt = Renderer.pts[i];
					pt[0] = this.cameraX + t * (triPoint[0] - this.cameraX);
					pt[1] = this.cameraY + t * (triPoint[1] - this.cameraY);
					pt[2] = this.cameraZ + t * (triPoint[2] - this.cameraZ);
				}
			}
		}
		
		// Renderer.pts now represents the point in SPACE where the triangle rays intersect the screen
		// convert these into screen coordinates
		
		if (ptCount == 3) {
			i = 3;
			
			drawPts = [];
			while (--i >= 0) {
				pt = Renderer.pts[i];
				px = pt[0];
				py = pt[1];
				pz = pt[2];
				
				// y is easy enough. The left side of the screen is always vertical.
				// subtract the z coordinate of the bottom of the screen which is cAz.
				// then divide by the length of the left side of the screen, which is Lz.
				// This converts the coordinate into a value from 0 to 1. which maps from 
				// the bottom of the screen to the top.
				y = SCREEN_HEIGHT - SCREEN_HEIGHT * (pz - this.screenAz) / LOGICAL_SCREEN_HEIGHT - SCREEN_HEIGHT / 2;
				
				// X is a little more complicated. The x and y coordinates of the point are guaranteed to be
				// along the screenA-screenB vector, so determine where on the vector it is as a ratio,
				// and then multiply the pixel screen width by that.
				if (Math.abs(this.screenBx - this.screenAx) > Math.abs(this.screenBy - this.screenAy)) {
					x = (px - this.screenAx) / (this.screenBx - this.screenAx);
				} else {
					x = (py - this.screenAy) / (this.screenBy - this.screenAy);
				}
				x = SCREEN_WIDTH * x / LOGICAL_SCREEN_WIDTH;
				
				drawPts.add(Math.floor(x), Math.floor(y) - 8); // -8 just because
			}
			
			GFX.Draw.triangle(
				drawPts[0], drawPts[1],
				drawPts[2], drawPts[3],
				drawPts[4], drawPts[5], 
				rgb[0], rgb[1], rgb[2]);
		}
	}
}

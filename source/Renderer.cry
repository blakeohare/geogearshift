import Math;

class Renderer {
	
	field playscene;
	field triangles = [];
	
	constructor(playscene) {
		this.playscene = playscene;
		
		segments = playscene.roadSegments;
		length = segments.length;
		zitem = [0.0];
		colors = [[255, 0, 0], [0, 128, 0], [0, 0, 255], [255, 255, 0]];
		for (i = 0; i < length - 1; ++i) {
			firstPair = segments[i];
			secondPair = segments[(i + 1) % length];
			a = firstPair[0] + zitem;
			b = firstPair[1] + zitem;
			c = secondPair[0] + zitem;
			d = secondPair[1] + zitem;
			
			rgb = colors[0];
			this.triangles.add([a, b, c, rgb[0], rgb[1], rgb[2]]);
			this.triangles.add([c, b, d, rgb[0] * 9 / 10, rgb[1] * 9 / 10, rgb[2] * 9 / 10]);
			colors = colors[1:] + [colors[0]];
		}
		
		a = [-1.0, -1.0];
		b = [-1.0, 1.0];
		c = [1.0, 1.0];
		d = [1.0, -1.0];
		
		aLower = a + zitem;
		bLower = b + zitem;
		cLower = c + zitem;
		dLower = d + zitem;
		titem = [2.0];
		aUpper = a + titem;
		bUpper = b + titem;
		cUpper = c + titem;
		dUpper = d + titem;
		
		this.triangles.add(
			[aLower, bLower, aUpper, 255, 255, 255],
			[aUpper, bUpper, bLower, 200, 200, 200],
			[bLower, cLower, bUpper, 100, 100, 100],
			[bUpper, cUpper, cLower, 50, 50, 50]
		);
		
		this.triangles = [];
		for (y = 0; y < 10; ++y) {
			for (x = 0; x < 10; ++x) {
				color = (x + y) % 2 == 0 ? 255 : 0;
				a = [x + 0.0, y + 0.0, 0.0];
				b = [x + 1.0, y + 0.0, 0.0];
				c = [x + 1.0, y + 1.0, 0.0];
				d = [x + 0.0, y + 1.0, 0.0];
				this.triangles.add(
					[a, b, c, color, color, color],
					[a, c, d, color, color, color]);
			}
		}
	}
	
	function drawBackground(playerTheta) {
		anglePercent = (playerTheta / Math.PI) % 1.0;
		GFX.Draw.fill(80, 180, 120);
		bg = ImageLibrary.get('backgrounds/level1.png');
		
		offset = Math.floor(anglePercent * bg.width);
		
		x = -offset;
		bg.draw(x, 0);
		x += bg.width;
		if (x < SCREEN_WIDTH) {
			bg.draw(x, 0);
		}
	}
	
	function getTriangleDistance(triangle) {
		player = this.playscene.player;
		a = triangle[0];
		b = triangle[1];
		c = triangle[2];
		
		dx = (a[0] + b[0] + c[0]) / 3 - player.x;
		dy = (a[1] + b[1] + c[1]) / 3 - player.y;
		dz = (a[2] + b[2] + c[2]) / 3;
		
		return dx ** 2 + dy ** 2 + dz ** 2;
	}
	
	// This function is super duper naive
	function getSortedTriangles() {
		triangles = this.triangles.clone();
		triangles.sort(this.getTriangleDistance);
		return triangles;
	}
	
	function render(counter) {
	
		player = this.playscene.player;
		playerX = player.x;
		playerY = player.y;
		playerZ = 0.0;
		toCamera = player.theta + Math.PI;
		
		this.drawBackground(player.theta);
		
		focusX = playerX;
		focusY = playerY;
		focusZ = .5; // look just above the player
		
		screenDistance = 2.0;
		screenX = Math.sin(toCamera) * screenDistance + focusX;
		screenY = Math.cos(toCamera) * screenDistance + focusY;
		screenZ = focusZ;
		
		mx = (screenX - focusX) / screenDistance;
		my = (screenY - focusY) / screenDistance;
		mz = (screenZ - focusZ) / screenDistance;
		
		eyeScreenDistance = 1.0; // adjust this to make the view angle wider (smaller means wider)
		eyeX = screenX + mx * eyeScreenDistance;
		eyeY = screenY + my * eyeScreenDistance;
		eyeZ = screenZ + mz * eyeScreenDistance;
		
		// correct
		//print([focusX, focusY, ' ', screenX, screenY, ' ', eyeX, eyeY]);
		
		screenHeight = .48;
		screenWidth = screenHeight * SCREEN_WIDTH / SCREEN_HEIGHT;
		
		theta = toCamera + HALF_PI;
		
		cAx = screenX + Math.sin(theta) * screenWidth / 2;
		cAy = screenY + Math.cos(theta) * screenWidth / 2;
		cAz = 0.5;
		
		cBx = 2 * screenX - cAx;
		cBy = 2 * screenY - cAy;
		cBz = 0.5;
		
		//print([cAx, cAy, cAz, ' ', cBx, cBy, cBz]);
		
		// compute camera vectors (left and bottom of "screen")
		
		// left side of the screen is a vertical vector
		Lx = 0.0;
		Ly = 0.0;
		Lz = screenHeight;
		
		// bottom side of the screen is level and goes between cA and cB
		Bx = cBx - cAx;
		By = cBy - cAy;
		Bz = cBz - cAz;
		
		// cross product to find normal vector
		Nx = Ly * Bz - By * Lz;
		Ny = Lz * Bx - Bz * Lx;
		Nz = Lx * By - Bx * Ly;
		
		N = (Nx * cAx + Ny * cAy + Nz * cAz);
		
		// The equation of the camera Plane is Nx * x + Ny * y + Nz * z = N
		
		pts = [
			[0] * 3,
			[0] * 3,
			[0] * 3];
		
		triangles = this.getSortedTriangles();
		for (triangle : triangles) {
			//print(triangle);
			ptCount = 0;
			i = 3;
			while (--i >= 0) {
				triPoint = triangle[i];
				ax = triPoint[0];
				ay = triPoint[1];
				az = triPoint[2];
				
				eqLeft = N - Nx * eyeX - Ny * eyeY - Nz * eyeZ;
				eqRight = Nx * (ax - eyeX) + Ny * (ay - eyeY) + Nz * (az - eyeZ);
				
				if (eqRight == 0) {
					// does not intersect
					t = null;
				} else {
					t = eqLeft / eqRight;
					if (t > 0) {
						ptCount++;
						pt = pts[i];
						pt[0] = eyeX + t * (ax - eyeX);
						pt[1] = eyeY + t * (ay - eyeY);
						pt[2] = eyeZ + t * (az - eyeZ);
					}
				}
			}
			
			// pts now represents the point in SPACE where the triangle rays intersect the screen
			// convert these into screen coordinates
			
			if (ptCount == 3) {
				i = 3;
				
				drawPts = [];
				while (--i >= 0) {
					pt = pts[i];
					px = pt[0];
					py = pt[1];
					pz = pt[2];
					
					// y is easy enough. The left side of the screen is always vertical.
					// subtract the z coordinate of the bottom of the screen which is cAz.
					// then divide by the length of the left side of the screen, which is Lz.
					// This converts the coordinate into a value from 0 to 1. which maps from 
					// the bottom of the screen to the top.
					y = SCREEN_HEIGHT - SCREEN_HEIGHT * (pz - cAz) / Lz - 250;
					if (Math.abs(cBx - cAx) > Math.abs(cBy - cAy)) {
						x = (px - cAx) / (cBx - cAx);
					} else {
						x = (py - cAy) / (cBy - cAy);
					}
					x = SCREEN_WIDTH * x / screenWidth;
					//x = SCREEN_WIDTH * ((px - cAx) ** 2 + (py - cAy) ** 2) ** .5 / screenWidth;
					drawPts.add(Math.floor(x), Math.floor(y));
				}
				
				r = triangle[3];
				g = triangle[4];
				b = triangle[5];
				GFX.Draw.triangle(drawPts[0], drawPts[1], drawPts[2], drawPts[3], drawPts[4], drawPts[5], r, g, b);
			}
			
		}
	}
}

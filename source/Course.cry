import JSON;
import Math;
import Resources;

/*
	The first three points are a triangle.
	The rest is a triangle strip.
*/

const COURSE_SCALE_RATIO = 3.0;

class Course {
	field id;
	field name;
	field music;
	field points = [];
	
	// Lookup of triangles for collision purposes.
	// Key is floor(x / 3) * 100000 + floor(y / 3) and value is a list of triangles whose bounding box touches that region.
	field collisionTriangles = null;
	
	// List of render objects
	field roadTriangles = null;
	
	// list of points determined by the midpoint of every other triangle edge.
	// The walls are placed along this path, perpendicular to it.
	field thePath = null;
	field totalDistance;
	field cumulativeDistance;
	field distanceToPrevious;
	field pathOriginalPoints;
	
	constructor(id) {
		this.id = id;
		json = Resources.readText('levels/' + id + '.json');
		print(json);
		rawData = JSON.parseJson(json);
		this.name = rawData.get('name') ?? "Untitled level";
		this.music = rawData.get('music');
		points = rawData.get('points', []);
		ratio = EDITOR_MODE ? 1.0 : COURSE_SCALE_RATIO;
		for (i = 0; i + 1 < points.length; i += 2) {
			this.points.add([ratio * points[i], ratio * points[i + 1]]);
		}
	}
	
	function getProgress(x, y) {
		path = this.getThePath();
		minDistance = 999999999;
		minIndex = 0;
		for (i = 0; i < path.length; ++i) {
			pt = path[i];
			dx = x - pt[0];
			dy = y - pt[1];
			dist = dx ** 2 + dy ** 2;
			if (dist < minDistance) {
				minDistance = dist;
				minIndex = i;
			}
		}
		
		i = minIndex;
		
		// minIndex is now the closest point.
		// determine if you're closer to its previous or next neighbor.
		prev = path[i - 1]; // this is okay for 0
		next = path[(i + 1) % path.length];
		
		prevDist = (prev[0] - x) ** 2 + (prev[1] - y) ** 2;
		nextDist = (next[0] - x) ** 2 + (next[1] - y) ** 2;
		
		if (prevDist < nextDist) i = (i - 1) % path.length;
		
		// player is located between points i and i + 1
		// you can *roughly* find the progress between them quickly by simply figuring out the ratio between the distances.
		// This gives more incorrect results the further away from the center of the road you are.
		// That's probably okay for our purposes and for the purposes of a game jam.
		
		j = (i + 1) % path.length;
		a12 = this.pathOriginalPoints[i];
		b12 = this.pathOriginalPoints[j];
		a1 = a12[0];
		a2 = a12[1];
		b1 = b12[0];
		b2 = b12[1];
		aProg = pointDistanceFromLine(a1[0], a1[1], a2[0], a2[1], x, y);
		bProg = pointDistanceFromLine(b1[0], b1[1], b2[0], b2[1], x, y);
		localProgress = aProg / (aProg + bProg);
		
		return (this.cumulativeDistance[i] + this.distanceToPrevious[j] * localProgress) / this.totalDistance;
	}
	
	function getThePath() {
		if (this.thePath == null) {
			
			path = [];
			pathOriginalPoints = [];
			for (i = 3; i < this.points.length; i += 2) {
				a = this.points[i];
				b = this.points[i - 1];
				mx = (a[0] + b[0]) / 2.0;
				my = (a[1] + b[1]) / 2.0;
				path.add([mx, my]);
				pathOriginalPoints.add([a, b]);
			}
			dx = path[0][0] - path[-1][0];
			dy = path[0][1] - path[-1][1];
			if (dx ** 2 + dy ** 2 < 3 ** 2) {
				// If there's overlap with the first and last, pop the last point.
				path = path[:-1];
				pathOriginalPoints = pathOriginalPoints[:-1];
			}
			this.thePath = path;
			
			distanceToPrevious = [0.0];
			for (i = 0; i < path.length; ++i) {
				prev = path[i];
				next = path[(i + 1) % path.length];
				
				dx = prev[0] - next[0];
				dy = prev[1] - next[1];
				
				dist = (dx ** 2 + dy ** 2) ** .5;
				distanceToPrevious.add(dist);
			}
			
			cumulativeDistance = [];
			total = 0.0;
			for (dist : distanceToPrevious) {
				cumulativeDistance.add(total);
				total += dist;
			}
			
			this.cumulativeDistance = cumulativeDistance;
			this.distanceToPrevious = distanceToPrevious;
			this.pathOriginalPoints = pathOriginalPoints;
			this.totalDistance = total;
		}
		return this.thePath;
	}
	
	function getRoadTriangles() {
		if (this.roadTriangles == null) {
			this.roadTriangles = [];
			for (i = 2; i < this.points.length; ++i) {
				a = this.points[i - 2];
				b = this.points[i - 1];
				c = this.points[i];
				avgX = (a[0] + b[0] + c[0]) / 3.0;
				avgY = (a[1] + b[1] + c[1]) / 3.0;
				
				// push the points out from the center by a distance of .04 in model coordinates.
				// This will help minimize the hairline crack problem in some rendering platforms.
				abc = [a, b, c];
				for (j = 0; j < 3; ++j) {
					p = abc[j];
					vx = p[0] - avgX;
					vy = p[1] - avgY;
					vd = (vx ** 2 + vy ** 2) ** .5;
					if (vd != 0) {
						vx = vx * (vd + .04) / vd;
						vy = vy * (vd + .04) / vd;
					}
					abc[j] = [vx + avgX, vy + avgY];
				}
				a = abc[0];
				b = abc[1];
				c = abc[2];
				
				this.roadTriangles.add([
					ObjectType.TRIANGLE,
					[
						avgX,
						avgY,
						0.0,
						0 // sort priority is low.
					],
					[a + [0.0], b + [0.0], c + [0.0]],
					[40, 40, 40],
				]);
			}
		}
		return this.roadTriangles;
	}
	
	// Find the cross product of two vectors: QR x ST
	function crossProductSign(qx, qy, rx, ry, sx, sy, tx, ty) {
		cp = (rx - qx) * (ty - sy) - (tx - sx) * (ry - qy);
		if (cp < 0) return -1;
		if (cp > 0) return 1;
		return 0;
	}
	
	function isInBounds(x, y) {
		if (this.collisionTriangles == null) {
			this.collisionTriangles = this.generateCollisionTriangles();
		}
		
		bucket = this.collisionTriangles.get(this.getCollisionKey(x, y));
		
		for (triangle : bucket) {
			a = triangle[0];
			b = triangle[1];
			c = triangle[2];
			
			ax = a[0];
			ay = a[1];
			bx = b[0];
			by = b[1];
			cx = c[0];
			cy = c[1];
			
			aSign = this.crossProductSign(ax, ay, bx, by, ax, ay, x, y);
			bSign = this.crossProductSign(bx, by, cx, cy, bx, by, x, y);
			cSign = this.crossProductSign(cx, cy, ax, ay, cx, cy, x, y);
			
			if (aSign != 1 && bSign != 1 && cSign != 1) return true;
			if (aSign != -1 && bSign != -1 && cSign != -1) return true;
		}
		return false;
	}
	
	function getCollisionKey(x, y) {
		return floor(x / 3) * 100000 + floor(y / 3);
	}
	
	function generateCollisionTriangles() {
		lookup = {};
		for (triangle : this.getRoadTriangles()) {
			abc = triangle[2].clone();
			a = abc[0];
			b = abc[1];
			c = abc[2];
			ax = a[0];
			ay = a[1];
			bx = b[0];
			by = b[1];
			cx = c[0];
			cy = c[1];
			left = Math.floor(Math.min(ax, Math.min(bx, cx)) / 3);
			right = Math.floor(Math.max(ax, Math.max(bx, cx)) / 3);
			top = Math.floor(Math.min(ay, Math.min(by, cy)) / 3);
			bottom = Math.floor(Math.max(ay, Math.max(by, cy)) / 3);
			for (x = left; x <= right; ++x) {
				for (y = top; y <= bottom; ++y) {
					key = x * 100000 + y;
					bucket = lookup.get(key);
					if (bucket == null) {
						bucket = [];
						lookup[key] = bucket;
					}
					bucket.add(abc);
				}
			}
		}
		return lookup;
	}
}

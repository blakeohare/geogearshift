// Nothing here yet.

import Math;

const ROTATION_VELOCITY = TWO_PI * .003; // 1%
const ACCEL_RATE = 0.05;

class Player {
	
	field x;
	field y;
	field vx = 0.0;
	field vy = 0.0;
	
	field theta; // 0 is facing the positive y axis and goes clockiwse
	
	constructor(x, y, theta) {
		this.x = x + 0.0;
		this.y = y + 0.0;
		this.theta = theta + 0.0;
	}
	
	function update(accelPressed, brakePressed, goLeft, goRight, course) {
		if (goLeft) {
			this.theta -= ROTATION_VELOCITY;
		} else if (goRight) {
			this.theta += ROTATION_VELOCITY;
		}
		
		v = 0;
		if (accelPressed) {
			v = .02;
		} else if (brakePressed) {
			this.vx *= .9;
			this.vy *= .9;
		}
		
		this.vx += Math.sin(this.theta) * v;
		this.vy += Math.cos(this.theta) * v;
		
		this.vx *= .96;
		this.vy *= .96;
		
		// remove some amount (conversionRatio) of the velocity vector and convert it into 
		// the direction the player is facing (i.e. "steering" instead of "sliding")
		conversionRatio = .5;
		vmag = (this.vx ** 2 + this.vy ** 2) ** .5; // velocity magnitude
		this.vx *= (1 - conversionRatio);
		this.vy *= (1 - conversionRatio);
		dmag = vmag * conversionRatio;
		dx = Math.sin(this.theta) * dmag;
		dy = Math.cos(this.theta) * dmag;
		
		
		this.vx += dx;
		this.vy += dy;
		
		newX = this.x + this.vx;
		newY = this.y + this.vy;
		
		if (course.isInBounds(newX, newY)) {
			this.x = newX;
			this.y = newY;
		} else {
			this.vx *= -.5;
			this.vy *= -.5;
		}
	}
	
	/*
		renderRow[1] -> location[x, y, z]
		renderRow[2] -> width
		renderRow[3] -> nullable image
	*/
	function renderUpdate(renderRow) {
		img = ImageLibrary.get('sprites/square.png');
		loc = renderRow[1];
		loc[0] = this.x;
		loc[1] = this.y;
		loc[2] = 0.0;
		
		renderRow[2] = .3; // seems about right.
		
		renderRow[3] = img;
	}
}